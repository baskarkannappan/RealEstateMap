@page "/"

@using RealEstateMap.Models
@using RealEstateMap.Services
@inject IJSRuntime JS
@inject IHouseService HouseService
@inject ILogger<MapPage> Logger
@implements IAsyncDisposable

<h3>Real Estate Map</h3>

<div class="search-panel mb-3 d-flex flex-wrap gap-2">
    <input class="form-control" style="max-width:180px" placeholder="Postal Code" @bind="PostalCode" />
    <input class="form-control" style="max-width:180px" placeholder="City" @bind="City" />
    <input class="form-control" style="max-width:180px" placeholder="State" @bind="State" />
    <input class="form-control" style="max-width:120px" type="number" min="1" max="250" @bind="RadiusKm" />
    <button class="btn btn-primary" @onclick="SearchAsync">Search</button>
</div>

@if (!string.IsNullOrWhiteSpace(StatusMessage))
{
    <div class="alert alert-secondary">@StatusMessage</div>
}

<div id="map" style="height:600px; width:100%;"></div>

@code {
    private DotNetObjectReference<MapPage>? _dotNetRef;
    private CancellationTokenSource? _moveDebounceCts;
    private readonly Dictionary<string, List<HouseLocation>> _boundsCache = new();
    private readonly HashSet<string> _inFlightBounds = new();

    private string? PostalCode;
    private string? City;
    private string? State;
    private double RadiusKm = 10;
    private string? StatusMessage;
    private string? _lastVisibleKey;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
        {
            return;
        }

        _dotNetRef = DotNetObjectReference.Create(this);
        await JS.InvokeVoidAsync("leafletInterop.initMap", "map", 39.8283, -98.5795, 5, _dotNetRef);
    }

    [JSInvokable(nameof(MapMoved))]
    public Task MapMoved(double south, double west, double north, double east, int zoom)
    {
        _moveDebounceCts?.Cancel();
        _moveDebounceCts?.Dispose();
        _moveDebounceCts = new CancellationTokenSource();

        return DebouncedMapMovedAsync(south, west, north, east, zoom, _moveDebounceCts.Token);
    }

    private async Task DebouncedMapMovedAsync(double south, double west, double north, double east, int zoom, CancellationToken cancellationToken)
    {
        try
        {
            await Task.Delay(300, cancellationToken);
            var visibleKey = BuildKey(south, west, north, east);
            if (_lastVisibleKey == visibleKey)
            {
                return;
            }

            _lastVisibleKey = visibleKey;
            StatusMessage = null;

            var expanded = ExpandBounds(south, west, north, east, 0.25);
            var expandedKey = BuildKey(expanded.South, expanded.West, expanded.North, expanded.East);

            List<HouseLocation> data;
            if (!_boundsCache.TryGetValue(expandedKey, out data!))
            {
                if (_inFlightBounds.Contains(expandedKey))
                {
                    return;
                }

                _inFlightBounds.Add(expandedKey);
                try
                {
                    data = await HouseService.GetBoundsAsync(expanded.South, expanded.West, expanded.North, expanded.East);
                    _boundsCache[expandedKey] = data;
                    TrimCache(12);
                }
                finally
                {
                    _inFlightBounds.Remove(expandedKey);
                }
            }

            var visibleHouses = data
                .Where(h => h.Lat >= south && h.Lat <= north && h.Lng >= west && h.Lng <= east)
                .Take(500)
                .ToList();

            await RenderMarkersAsync(visibleHouses, zoom);
        }
        catch (TaskCanceledException)
        {
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed while handling map movement.");
            StatusMessage = "Map data is temporarily unavailable. You can keep using the map.";
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task RenderMarkersAsync(List<HouseLocation> houses, int zoom)
    {
        await JS.InvokeVoidAsync("leafletInterop.clearLayers");

        if (zoom < 10)
        {
            var clusters = houses
                .GroupBy(h => (Math.Round(h.Lat, 1), Math.Round(h.Lng, 1)))
                .Select(group => new { group.Key.Item1, group.Key.Item2, Count = group.Count() });

            foreach (var cluster in clusters)
            {
                await JS.InvokeVoidAsync("leafletInterop.addClusterCount", cluster.Item1, cluster.Item2, cluster.Count);
            }

            return;
        }

        foreach (var house in houses)
        {
            await JS.InvokeVoidAsync(
                "leafletInterop.addMarker",
                house.Lat,
                house.Lng,
                $"{house.Address} - {house.City}, {house.State} ({house.PostalCode})");
        }
    }

    private async Task SearchAsync()
    {
        try
        {
            var request = new MapSearchRequest
            {
                PostalCode = PostalCode,
                City = City,
                State = State,
                RadiusKm = RadiusKm
            };

            var results = await HouseService.SearchAsync(request);
            if (results.Count == 0)
            {
                StatusMessage = "No houses matched your search.";
                return;
            }

            var center = results[0];
            await JS.InvokeVoidAsync("leafletInterop.showSearchResult", center.Lat, center.Lng, 12, RadiusKm);
            await RenderMarkersAsync(results.Take(500).ToList(), 12);
            StatusMessage = $"Loaded {results.Count} houses.";
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Search operation failed.");
            StatusMessage = "Search is temporarily unavailable. Try again in a moment.";
        }
    }

    public async ValueTask DisposeAsync()
    {
        _moveDebounceCts?.Cancel();
        _moveDebounceCts?.Dispose();
        if (_dotNetRef is not null)
        {
            await JS.InvokeVoidAsync("leafletInterop.disposeMap");
            _dotNetRef.Dispose();
        }
    }

    private static (double South, double West, double North, double East) ExpandBounds(
        double south,
        double west,
        double north,
        double east,
        double factor)
    {
        var latPad = (north - south) * factor;
        var lngPad = (east - west) * factor;

        return (south - latPad, west - lngPad, north + latPad, east + lngPad);
    }

    private static string BuildKey(double south, double west, double north, double east) =>
        $"{Math.Round(south, 2)}:{Math.Round(west, 2)}:{Math.Round(north, 2)}:{Math.Round(east, 2)}";

    private void TrimCache(int maxEntries)
    {
        while (_boundsCache.Count > maxEntries)
        {
            var firstKey = _boundsCache.Keys.First();
            _boundsCache.Remove(firstKey);
        }
    }
}
