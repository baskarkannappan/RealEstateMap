@page "/"
@using RealEstateMap.Models
@using RealEstateMap.Services
@inject IJSRuntime JS
@inject IHouseService HouseService
@inject ILogger<MapPage> Logger
@implements IAsyncDisposable

<h3>Real Estate Map</h3>

<div class="search-panel mb-3 d-flex flex-wrap gap-2">
    <input class="form-control" style="max-width:180px" placeholder="Postal Code" @bind="PostalCode" />
    <input class="form-control" style="max-width:180px" placeholder="City" @bind="City" />
    <input class="form-control" style="max-width:180px" placeholder="State" @bind="State" />
    <input class="form-control" style="max-width:120px" type="number" min="1" max="250" @bind="RadiusKm" />
    <button class="btn btn-primary" @onclick="SearchAsync">Search</button>
</div>

@if (!string.IsNullOrWhiteSpace(StatusMessage))
{
    <div class="alert alert-secondary">@StatusMessage</div>
}

<div id="map" style="height:600px; width:100%;"></div>

@code {
    private const int MarkerLimit = 200;

    private DotNetObjectReference<MapPage>? _dotNetRef;
    private CancellationTokenSource? _debounceCts;
    private readonly SemaphoreSlim _mapMoveLock = new(1, 1);
    private readonly Dictionary<string, List<HouseLocation>> _boundsCache = new();
    private readonly Dictionary<string, string> _cityColors = new(StringComparer.OrdinalIgnoreCase);
    private readonly Queue<string> _cacheOrder = new();

    private int _mapMoveVersion;
    private string? _lastVisualBucket;

    private string? PostalCode;
    private string? City;
    private string? State;
    private double RadiusKm = 10;
    private string? StatusMessage;

    [JSInvokable(nameof(MapMoved))]
    public Task MapMoved(double south, double west, double north, double east, int zoom)
    {
        _debounceCts?.Cancel();
        _debounceCts?.Dispose();
        _debounceCts = new CancellationTokenSource();

        var version = Interlocked.Increment(ref _mapMoveVersion);
        return HandleMapMoveDebouncedAsync(south, west, north, east, zoom, version, _debounceCts.Token);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
        {
            return;
        }

        _dotNetRef = DotNetObjectReference.Create(this);
        await JS.InvokeVoidAsync("leafletInterop.initMap", "map", 39.8283, -98.5795, 5, _dotNetRef);
    }

    private async Task HandleMapMoveDebouncedAsync(
        double south,
        double west,
        double north,
        double east,
        int zoom,
        int version,
        CancellationToken cancellationToken)
    {
        try
        {
            await Task.Delay(300, cancellationToken);
            var bucket = BuildVisualBucket(south, west, north, east, zoom);
            if (_lastVisualBucket == bucket)
            {
                return;
            }

            await _mapMoveLock.WaitAsync(cancellationToken);
            try
            {
                // Ignore stale requests after awaiting lock.
                if (version != _mapMoveVersion)
                {
                    return;
                }

                _lastVisualBucket = bucket;
                StatusMessage = null;

                var expanded = ExpandBounds(south, west, north, east, 0.35);
                var cacheKey = BuildCacheKey(expanded.South, expanded.West, expanded.North, expanded.East);

                if (!_boundsCache.TryGetValue(cacheKey, out var cached))
                {
                    cached = await HouseService.GetBoundsAsync(expanded.South, expanded.West, expanded.North, expanded.East);
                    AddCacheEntry(cacheKey, cached);
                }

                var visible = cached
                    .Where(h => h.Lat >= south && h.Lat <= north && h.Lng >= west && h.Lng <= east)
                    .Take(MarkerLimit)
                    .ToList();

                await RenderMarkersAsync(visible, zoom);
                await InvokeAsync(StateHasChanged);
            }
            finally
            {
                _mapMoveLock.Release();
            }
        }
        catch (OperationCanceledException)
        {
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Map movement handling failed.");
            StatusMessage = "Map data is temporarily unavailable. Keep navigating and retry.";
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task SearchAsync()
    {
        try
        {
            var request = new MapSearchRequest
            {
                PostalCode = string.IsNullOrWhiteSpace(PostalCode) ? null : PostalCode.Trim(),
                City = string.IsNullOrWhiteSpace(City) ? null : City.Trim(),
                State = string.IsNullOrWhiteSpace(State) ? null : State.Trim(),
                RadiusKm = Math.Clamp(RadiusKm, 1, 250)
            };

            var results = await HouseService.SearchAsync(request);
            if (results.Count == 0)
            {
                StatusMessage = "No properties matched your search.";
                await JS.InvokeVoidAsync("leafletInterop.clearLayers");
                return;
            }

            var center = results[0];
            var limited = results.Take(MarkerLimit).ToList();
            await JS.InvokeVoidAsync("leafletInterop.showSearchResult", center.Lat, center.Lng, 12, request.RadiusKm);
            await RenderMarkersAsync(limited, 12);

            StatusMessage = $"Loaded {limited.Count} properties.";
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Search failed.");
            StatusMessage = "Search is temporarily unavailable. Please try again.";
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task RenderMarkersAsync(List<HouseLocation> houses, int zoom)
    {
        await JS.InvokeVoidAsync("leafletInterop.clearLayers");

        if (zoom < 10)
        {
            var grouped = houses
                .GroupBy(h => (Math.Round(h.Lat, 1), Math.Round(h.Lng, 1)))
                .Select(group => new { group.Key.Item1, group.Key.Item2, Count = group.Count() });

            foreach (var cluster in grouped)
            {
                await JS.InvokeVoidAsync("leafletInterop.addClusterCount", cluster.Item1, cluster.Item2, cluster.Count);
            }

            return;
        }

        foreach (var house in houses)
        {
            var color = GetCityColor(house.City);
            await JS.InvokeVoidAsync(
                "leafletInterop.addMarker",
                house.Lat,
                house.Lng,
                $"{house.Address} - {house.City}, {house.State} ({house.PostalCode})",
                color);
        }
    }

    private string GetCityColor(string city)
    {
        if (string.IsNullOrWhiteSpace(city))
        {
            return "#1f77b4";
        }

        if (_cityColors.TryGetValue(city, out var existingColor))
        {
            return existingColor;
        }

        var hue = Math.Abs(city.GetHashCode()) % 360;
        var generated = $"hsl({hue}, 70%, 45%)";
        _cityColors[city] = generated;
        return generated;
    }

    private void AddCacheEntry(string key, List<HouseLocation> value)
    {
        if (_boundsCache.ContainsKey(key))
        {
            return;
        }

        _boundsCache[key] = value;
        _cacheOrder.Enqueue(key);

        while (_cacheOrder.Count > 12)
        {
            var toRemove = _cacheOrder.Dequeue();
            _boundsCache.Remove(toRemove);
        }
    }

    private static (double South, double West, double North, double East) ExpandBounds(
        double south,
        double west,
        double north,
        double east,
        double factor)
    {
        var latPad = (north - south) * factor;
        var lngPad = (east - west) * factor;
        return (south - latPad, west - lngPad, north + latPad, east + lngPad);
    }

    private static string BuildCacheKey(double south, double west, double north, double east) =>
        $"{Math.Round(south, 2)}:{Math.Round(west, 2)}:{Math.Round(north, 2)}:{Math.Round(east, 2)}";

    private static string BuildVisualBucket(double south, double west, double north, double east, int zoom) =>
        $"{Math.Round((south + north) / 2, 2)}:{Math.Round((west + east) / 2, 2)}:{Math.Round(north - south, 2)}:{zoom}";

    public async ValueTask DisposeAsync()
    {
        _debounceCts?.Cancel();
        _debounceCts?.Dispose();
        _mapMoveLock.Dispose();

        if (_dotNetRef is not null)
        {
            try
            {
                await JS.InvokeVoidAsync("leafletInterop.disposeMap");
            }
            catch (Exception ex)
            {
                Logger.LogDebug(ex, "Map JS disposal failed during teardown.");
            }

            _dotNetRef.Dispose();
        }
    }
}
