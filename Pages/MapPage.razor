@page "/"
@using System.Text.RegularExpressions
@using RealEstateMap.Models
@using RealEstateMap.Services
@inject IJSRuntime JS
@inject IHouseService HouseService
@inject ILogger<MapPage> Logger
@implements IAsyncDisposable

<div class="map-page">
    <div class="top-bar">
        <h3>India Real Estate Map</h3>
        <button class="btn btn-outline-primary toggle-btn" @onclick="ToggleMapAsync">
            @(IsMapVisible ? "Hide Map" : "Show Map")
        </button>
    </div>

    <div class="search-panel responsive-grid">
        <input class="form-control" placeholder="PIN Code (6 digits)" @bind="PostalCode" />
        <input class="form-control" placeholder="City" @bind="City" />
        <input class="form-control" placeholder="State" @bind="State" />
        <input class="form-control" type="number" min="1" max="250" @bind="RadiusKm" />
        <button class="btn btn-primary search-btn" @onclick="SearchAsync">Search</button>
    </div>

    @if (!string.IsNullOrWhiteSpace(StatusMessage))
    {
        <div class="alert alert-secondary">@StatusMessage</div>
    }

    @if (IsMapVisible)
    {
        <div id="map" class="map-container"></div>
    }
    else
    {
        <HouseListView Houses="ListViewData" OnSelect="OnHouseSelectedAsync" />
    }
</div>

@code {
    private const int MarkerLimit = 200;
    private static readonly Regex PinRegex = new("^\\d{6}$", RegexOptions.Compiled);

    private static readonly Dictionary<string, (double Lat, double Lng)> PinCenters = new(StringComparer.OrdinalIgnoreCase)
    {
        ["110001"] = (28.6328, 77.2197),
        ["400001"] = (18.9388, 72.8354),
        ["560001"] = (12.9763, 77.6033),
        ["500001"] = (17.3850, 78.4867),
        ["600001"] = (13.0827, 80.2707),
        ["700001"] = (22.5726, 88.3639),
        ["411001"] = (18.5204, 73.8567),
        ["380001"] = (23.0225, 72.5714),
        ["302001"] = (26.9124, 75.7873),
        ["226001"] = (26.8467, 80.9462)
    };

    private static readonly Dictionary<string, (double Lat, double Lng)> PinPrefixCenters = new(StringComparer.OrdinalIgnoreCase)
    {
        ["110"] = (28.6139, 77.2090),
        ["400"] = (19.0760, 72.8777),
        ["560"] = (12.9716, 77.5946),
        ["500"] = (17.3850, 78.4867),
        ["600"] = (13.0827, 80.2707),
        ["700"] = (22.5726, 88.3639),
        ["411"] = (18.5204, 73.8567),
        ["380"] = (23.0225, 72.5714),
        ["302"] = (26.9124, 75.7873),
        ["226"] = (26.8467, 80.9462)
    };

    private static readonly Dictionary<string, (double Lat, double Lng)> CityCenters = new(StringComparer.OrdinalIgnoreCase)
    {
        ["mumbai|maharashtra"] = (19.0760, 72.8777),
        ["delhi|delhi"] = (28.6139, 77.2090),
        ["bengaluru|karnataka"] = (12.9716, 77.5946),
        ["hyderabad|telangana"] = (17.3850, 78.4867),
        ["chennai|tamil nadu"] = (13.0827, 80.2707),
        ["kolkata|west bengal"] = (22.5726, 88.3639),
        ["pune|maharashtra"] = (18.5204, 73.8567),
        ["ahmedabad|gujarat"] = (23.0225, 72.5714),
        ["jaipur|rajasthan"] = (26.9124, 75.7873),
        ["lucknow|uttar pradesh"] = (26.8467, 80.9462),
        ["mumbai"] = (19.0760, 72.8777),
        ["delhi"] = (28.6139, 77.2090),
        ["bengaluru"] = (12.9716, 77.5946),
        ["hyderabad"] = (17.3850, 78.4867),
        ["chennai"] = (13.0827, 80.2707),
        ["kolkata"] = (22.5726, 88.3639),
        ["pune"] = (18.5204, 73.8567),
        ["ahmedabad"] = (23.0225, 72.5714),
        ["jaipur"] = (26.9124, 75.7873),
        ["lucknow"] = (26.8467, 80.9462)
    };

    private DotNetObjectReference<MapPage>? _dotNetRef;
    private CancellationTokenSource? _debounceCts;
    private readonly SemaphoreSlim _moveSemaphore = new(1, 1);
    private readonly Dictionary<string, List<HouseLocation>> _boundsCache = new();
    private readonly Queue<string> _cacheOrder = new();
    private readonly Dictionary<string, string> _cityColors = new(StringComparer.OrdinalIgnoreCase);
    private readonly Dictionary<string, List<HouseLocation>> _listCache = new();

    private int _moveVersion;
    private string? _lastVisualBucket;
    private bool _mapInitialized;
    private bool _pendingMapInit = true;

    private bool IsMapVisible = true;
    private double _savedLat = 20.5937;
    private double _savedLng = 78.9629;
    private int _savedZoom = 5;

    private string? PostalCode;
    private string? City;
    private string? State;
    private double RadiusKm = 10;
    private string? StatusMessage;
    private List<HouseLocation> ListViewData = [];

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (IsMapVisible && (_pendingMapInit || firstRender) && !_mapInitialized)
        {
            _dotNetRef ??= DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("leafletInterop.initMap", "map", _savedLat, _savedLng, _savedZoom, _dotNetRef);
            _pendingMapInit = false;
            _mapInitialized = true;
        }
    }

    [JSInvokable(nameof(MapMoved))]
    public Task MapMoved(double south, double west, double north, double east, int zoom)
    {
        if (!IsMapVisible)
        {
            return Task.CompletedTask;
        }

        _debounceCts?.Cancel();
        _debounceCts?.Dispose();
        _debounceCts = new CancellationTokenSource();

        var version = Interlocked.Increment(ref _moveVersion);
        return ProcessMoveDebouncedAsync(south, west, north, east, zoom, version, _debounceCts.Token);
    }

    private async Task ProcessMoveDebouncedAsync(
        double south,
        double west,
        double north,
        double east,
        int zoom,
        int version,
        CancellationToken cancellationToken)
    {
        try
        {
            await Task.Delay(300, cancellationToken);
            if (!IsMapVisible)
            {
                return;
            }

            var bucket = BuildVisualBucket(south, west, north, east, zoom);
            if (_lastVisualBucket == bucket)
            {
                return;
            }

            await _moveSemaphore.WaitAsync(cancellationToken);
            try
            {
                if (version != _moveVersion || !IsMapVisible)
                {
                    return;
                }

                _lastVisualBucket = bucket;
                StatusMessage = null;

                var expanded = ExpandBounds(south, west, north, east, 0.35);
                var cacheKey = BuildCacheKey(expanded.South, expanded.West, expanded.North, expanded.East);

                if (!_boundsCache.TryGetValue(cacheKey, out var candidates))
                {
                    Logger.LogInformation("Fetching bounds from API: {South},{West},{North},{East}", expanded.South, expanded.West, expanded.North, expanded.East);
                    candidates = await HouseService.GetBoundsAsync(expanded.South, expanded.West, expanded.North, expanded.East, cancellationToken);
                    AddCacheEntry(cacheKey, candidates);
                }

                var visible = candidates
                    .Where(h => h.Lat >= south && h.Lat <= north && h.Lng >= west && h.Lng <= east)
                    .Take(MarkerLimit)
                    .ToList();

                ListViewData = visible;
                await RenderMarkersAsync(visible, zoom);
                await InvokeAsync(StateHasChanged);
            }
            finally
            {
                _moveSemaphore.Release();
            }
        }
        catch (OperationCanceledException)
        {
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "MapMoved pipeline failed.");
            StatusMessage = "Unable to load map data currently. Please continue navigating.";
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task SearchAsync()
    {
        try
        {
            var request = BuildSearchRequest();
            if (request is null)
            {
                return;
            }

            var listCacheKey = $"{request.PostalCode}|{request.City}|{request.State}|{request.CenterLat}|{request.CenterLng}|{request.RadiusKm}";
            if (!_listCache.TryGetValue(listCacheKey, out var listResults))
            {
                listResults = await HouseService.GetListAsync(request);
                _listCache[listCacheKey] = listResults;
            }

            ListViewData = listResults.Take(MarkerLimit).ToList();

            if (!IsMapVisible)
            {
                StatusMessage = $"Loaded {ListViewData.Count} properties in list view.";
                await InvokeAsync(StateHasChanged);
                return;
            }

            var mapResults = await HouseService.SearchAsync(request);
            if (mapResults.Count == 0)
            {
                StatusMessage = "No properties matched your filters.";
                await JS.InvokeVoidAsync("leafletInterop.clearLayers");
                await JS.InvokeVoidAsync("leafletInterop.showSearchResult", request.CenterLat!.Value, request.CenterLng!.Value, 12, request.RadiusKm);
                await InvokeAsync(StateHasChanged);
                return;
            }

            var centerLat = request.CenterLat ?? _savedLat;
            var centerLng = request.CenterLng ?? _savedLng;
            _savedLat = centerLat;
            _savedLng = centerLng;
            _savedZoom = 12;

            var limited = mapResults.Take(MarkerLimit).ToList();
            await JS.InvokeVoidAsync("leafletInterop.showSearchResult", centerLat, centerLng, 12, request.RadiusKm);
            await RenderMarkersAsync(limited, 12);

            StatusMessage = $"Loaded {limited.Count} properties.";
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Search pipeline failed.");
            StatusMessage = "Search is temporarily unavailable.";
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task ToggleMapAsync()
    {
        try
        {
            if (IsMapVisible)
            {
                try
                {
                    var view = await JS.InvokeAsync<MapViewState?>("leafletInterop.getCurrentView");
                    if (view is not null)
                    {
                        _savedLat = view.Lat;
                        _savedLng = view.Lng;
                        _savedZoom = view.Zoom;
                    }
                }
                catch (Exception ex)
                {
                    Logger.LogDebug(ex, "Unable to read current map view before hide.");
                }

                await JS.InvokeVoidAsync("leafletInterop.disposeMap");
                _mapInitialized = false;
                IsMapVisible = false;

                var request = BuildSearchRequest();
                if (request is not null)
                {
                    ListViewData = await HouseService.GetListAsync(request);
                }
            }
            else
            {
                IsMapVisible = true;
                _pendingMapInit = true;
                _mapInitialized = false;
            }

            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed toggling map/list view.");
        }
    }

    private async Task OnHouseSelectedAsync(HouseLocation house)
    {
        StatusMessage = $"Selected: {house.Address} ({house.City})";

        if (!IsMapVisible)
        {
            return;
        }

        _savedLat = house.Lat;
        _savedLng = house.Lng;
        _savedZoom = Math.Max(_savedZoom, 12);
        await JS.InvokeVoidAsync("leafletInterop.showSearchResult", _savedLat, _savedLng, _savedZoom, RadiusKm);
    }

    private MapSearchRequest? BuildSearchRequest()
    {
        var pin = string.IsNullOrWhiteSpace(PostalCode) ? null : PostalCode.Trim();
        if (!string.IsNullOrWhiteSpace(pin) && !PinRegex.IsMatch(pin))
        {
            StatusMessage = "Please enter a valid 6-digit Indian PIN code.";
            return null;
        }

        var city = string.IsNullOrWhiteSpace(City) ? null : City.Trim();
        var state = string.IsNullOrWhiteSpace(State) ? null : State.Trim();

        if (!TryResolveCenter(pin, city, state, out var centerLat, out var centerLng))
        {
            StatusMessage = "Could not resolve search center for the provided India location.";
            return null;
        }

        return new MapSearchRequest
        {
            PostalCode = pin,
            City = city,
            State = state,
            CenterLat = centerLat,
            CenterLng = centerLng,
            RadiusKm = Math.Clamp(RadiusKm, 1, 250)
        };
    }

    private static bool TryResolveCenter(string? postalCode, string? city, string? state, out double lat, out double lng)
    {
        if (!string.IsNullOrWhiteSpace(postalCode))
        {
            if (PinCenters.TryGetValue(postalCode, out var exactPinCenter))
            {
                lat = exactPinCenter.Lat;
                lng = exactPinCenter.Lng;
                return true;
            }

            if (postalCode.Length >= 3)
            {
                var prefix = postalCode[..3];
                if (PinPrefixCenters.TryGetValue(prefix, out var prefixCenter))
                {
                    lat = prefixCenter.Lat;
                    lng = prefixCenter.Lng;
                    return true;
                }
            }
        }

        if (!string.IsNullOrWhiteSpace(city) && !string.IsNullOrWhiteSpace(state))
        {
            var key = $"{city.ToLowerInvariant()}|{state.ToLowerInvariant()}";
            if (CityCenters.TryGetValue(key, out var cityStateCenter))
            {
                lat = cityStateCenter.Lat;
                lng = cityStateCenter.Lng;
                return true;
            }
        }

        if (!string.IsNullOrWhiteSpace(city) && CityCenters.TryGetValue(city.ToLowerInvariant(), out var cityCenter))
        {
            lat = cityCenter.Lat;
            lng = cityCenter.Lng;
            return true;
        }

        lat = 0;
        lng = 0;
        return false;
    }

    private async Task RenderMarkersAsync(List<HouseLocation> houses, int zoom)
    {
        if (!IsMapVisible)
        {
            return;
        }

        await JS.InvokeVoidAsync("leafletInterop.clearLayers");

        if (zoom < 10)
        {
            var grouped = houses
                .GroupBy(h => (Math.Round(h.Lat, 1), Math.Round(h.Lng, 1)))
                .Select(group => new { Lat = group.Key.Item1, Lng = group.Key.Item2, Count = group.Count() });

            foreach (var cluster in grouped)
            {
                await JS.InvokeVoidAsync("leafletInterop.addClusterCount", cluster.Lat, cluster.Lng, cluster.Count);
            }

            return;
        }

        foreach (var house in houses)
        {
            var color = GetCityColor(house.City);
            await JS.InvokeVoidAsync(
                "leafletInterop.addMarker",
                house.Lat,
                house.Lng,
                $"{house.Address} - {house.City}, {house.State} ({house.PostalCode})",
                color);
        }
    }

    private string GetCityColor(string city)
    {
        if (string.IsNullOrWhiteSpace(city))
        {
            return "#1f77b4";
        }

        if (_cityColors.TryGetValue(city, out var color))
        {
            return color;
        }

        var hue = Math.Abs(city.GetHashCode()) % 360;
        color = $"hsl({hue}, 70%, 45%)";
        _cityColors[city] = color;
        return color;
    }

    private void AddCacheEntry(string key, List<HouseLocation> data)
    {
        if (_boundsCache.ContainsKey(key))
        {
            return;
        }

        _boundsCache[key] = data;
        _cacheOrder.Enqueue(key);

        while (_cacheOrder.Count > 12)
        {
            var oldKey = _cacheOrder.Dequeue();
            _boundsCache.Remove(oldKey);
        }
    }

    private static (double South, double West, double North, double East) ExpandBounds(
        double south,
        double west,
        double north,
        double east,
        double factor)
    {
        var latPad = (north - south) * factor;
        var lngPad = (east - west) * factor;
        return (south - latPad, west - lngPad, north + latPad, east + lngPad);
    }

    private static string BuildCacheKey(double south, double west, double north, double east) =>
        $"{Math.Round(south, 2)}:{Math.Round(west, 2)}:{Math.Round(north, 2)}:{Math.Round(east, 2)}";

    private static string BuildVisualBucket(double south, double west, double north, double east, int zoom) =>
        $"{Math.Round((south + north) / 2, 2)}:{Math.Round((west + east) / 2, 2)}:{Math.Round(north - south, 2)}:{zoom}";

    public async ValueTask DisposeAsync()
    {
        _debounceCts?.Cancel();
        _debounceCts?.Dispose();
        _moveSemaphore.Dispose();

        if (_dotNetRef is not null)
        {
            try
            {
                await JS.InvokeVoidAsync("leafletInterop.disposeMap");
            }
            catch (Exception ex)
            {
                Logger.LogDebug(ex, "Error while disposing map interop.");
            }

            _dotNetRef.Dispose();
        }
    }

    private sealed class MapViewState
    {
        public double Lat { get; set; }
        public double Lng { get; set; }
        public int Zoom { get; set; }
    }
}
