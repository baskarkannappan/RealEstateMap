@page "/"
@using System.Text.RegularExpressions
@using RealEstateMap.Models
@using RealEstateMap.Services
@inject IJSRuntime JS
@inject IHouseService HouseService
@inject ILogger<MapPage> Logger
@implements IAsyncDisposable

<h3>India Real Estate Map</h3>

<div class="search-panel mb-3 d-flex flex-wrap gap-2">
    <input class="form-control" style="max-width:180px" placeholder="PIN Code (6 digits)" @bind="PostalCode" />
    <input class="form-control" style="max-width:180px" placeholder="City" @bind="City" />
    <input class="form-control" style="max-width:180px" placeholder="State" @bind="State" />
    <input class="form-control" style="max-width:120px" type="number" min="1" max="250" @bind="RadiusKm" />
    <button class="btn btn-primary" @onclick="SearchAsync">Search</button>
</div>

@if (!string.IsNullOrWhiteSpace(StatusMessage))
{
    <div class="alert alert-secondary">@StatusMessage</div>
}

<div id="map" style="height:600px; width:100%;"></div>

@code {
    private const int MarkerLimit = 200;
    private static readonly Regex PinRegex = new("^\\d{6}$", RegexOptions.Compiled);

    private DotNetObjectReference<MapPage>? _dotNetRef;
    private CancellationTokenSource? _debounceCts;
    private readonly SemaphoreSlim _moveSemaphore = new(1, 1);
    private readonly Dictionary<string, List<HouseLocation>> _boundsCache = new();
    private readonly Queue<string> _cacheOrder = new();
    private readonly Dictionary<string, string> _cityColors = new(StringComparer.OrdinalIgnoreCase);

    private int _moveVersion;
    private string? _lastVisualBucket;

    private string? PostalCode;
    private string? City;
    private string? State;
    private double RadiusKm = 10;
    private string? StatusMessage;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
        {
            return;
        }

        _dotNetRef = DotNetObjectReference.Create(this);

        // India center (approx) + India-friendly zoom.
        await JS.InvokeVoidAsync("leafletInterop.initMap", "map", 20.5937, 78.9629, 5, _dotNetRef);
    }

    [JSInvokable(nameof(MapMoved))]
    public Task MapMoved(double south, double west, double north, double east, int zoom)
    {
        _debounceCts?.Cancel();
        _debounceCts?.Dispose();
        _debounceCts = new CancellationTokenSource();

        var version = Interlocked.Increment(ref _moveVersion);
        return ProcessMoveDebouncedAsync(south, west, north, east, zoom, version, _debounceCts.Token);
    }

    private async Task ProcessMoveDebouncedAsync(
        double south,
        double west,
        double north,
        double east,
        int zoom,
        int version,
        CancellationToken cancellationToken)
    {
        try
        {
            await Task.Delay(300, cancellationToken);

            var bucket = BuildVisualBucket(south, west, north, east, zoom);
            if (_lastVisualBucket == bucket)
            {
                return;
            }

            await _moveSemaphore.WaitAsync(cancellationToken);
            try
            {
                if (version != _moveVersion)
                {
                    return;
                }

                _lastVisualBucket = bucket;
                StatusMessage = null;

                var expanded = ExpandBounds(south, west, north, east, 0.35);
                var cacheKey = BuildCacheKey(expanded.South, expanded.West, expanded.North, expanded.East);

                List<HouseLocation> candidates;
                if (!_boundsCache.TryGetValue(cacheKey, out candidates!))
                {
                    Logger.LogInformation("Fetching bounds from API: {South},{West},{North},{East}", expanded.South, expanded.West, expanded.North, expanded.East);
                    candidates = await HouseService.GetBoundsAsync(expanded.South, expanded.West, expanded.North, expanded.East, cancellationToken);
                    AddCacheEntry(cacheKey, candidates);
                }

                var visible = candidates
                    .Where(h => h.Lat >= south && h.Lat <= north && h.Lng >= west && h.Lng <= east)
                    .Take(MarkerLimit)
                    .ToList();

                await RenderMarkersAsync(visible, zoom);
                await InvokeAsync(StateHasChanged);
            }
            finally
            {
                _moveSemaphore.Release();
            }
        }
        catch (OperationCanceledException)
        {
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "MapMoved pipeline failed.");
            StatusMessage = "Unable to load map data currently. Please continue navigating.";
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task SearchAsync()
    {
        try
        {
            var pin = string.IsNullOrWhiteSpace(PostalCode) ? null : PostalCode.Trim();
            if (!string.IsNullOrWhiteSpace(pin) && !PinRegex.IsMatch(pin))
            {
                StatusMessage = "Please enter a valid 6-digit Indian PIN code.";
                return;
            }

            var request = new MapSearchRequest
            {
                PostalCode = pin,
                City = string.IsNullOrWhiteSpace(City) ? null : City.Trim(),
                State = string.IsNullOrWhiteSpace(State) ? null : State.Trim(),
                RadiusKm = Math.Clamp(RadiusKm, 1, 250)
            };

            Logger.LogInformation("Running India search. PIN:{Pin}, City:{City}, State:{State}, RadiusKm:{Radius}", request.PostalCode, request.City, request.State, request.RadiusKm);
            var results = await HouseService.SearchAsync(request);

            if (results.Count == 0)
            {
                StatusMessage = "No properties matched your filters.";
                await JS.InvokeVoidAsync("leafletInterop.clearLayers");
                await InvokeAsync(StateHasChanged);
                return;
            }

            var center = results[0];
            var limited = results.Take(MarkerLimit).ToList();

            await JS.InvokeVoidAsync("leafletInterop.showSearchResult", center.Lat, center.Lng, 12, request.RadiusKm);
            await RenderMarkersAsync(limited, 12);

            StatusMessage = $"Loaded {limited.Count} properties.";
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Search pipeline failed.");
            StatusMessage = "Search is temporarily unavailable.";
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task RenderMarkersAsync(List<HouseLocation> houses, int zoom)
    {
        await JS.InvokeVoidAsync("leafletInterop.clearLayers");

        if (zoom < 10)
        {
            var grouped = houses
                .GroupBy(h => (Math.Round(h.Lat, 1), Math.Round(h.Lng, 1)))
                .Select(group => new { Lat = group.Key.Item1, Lng = group.Key.Item2, Count = group.Count() });

            foreach (var cluster in grouped)
            {
                await JS.InvokeVoidAsync("leafletInterop.addClusterCount", cluster.Lat, cluster.Lng, cluster.Count);
            }

            return;
        }

        foreach (var house in houses)
        {
            var color = GetCityColor(house.City);
            await JS.InvokeVoidAsync(
                "leafletInterop.addMarker",
                house.Lat,
                house.Lng,
                $"{house.Address} - {house.City}, {house.State} ({house.PostalCode})",
                color);
        }
    }

    private string GetCityColor(string city)
    {
        if (string.IsNullOrWhiteSpace(city))
        {
            return "#1f77b4";
        }

        if (_cityColors.TryGetValue(city, out var color))
        {
            return color;
        }

        var hue = Math.Abs(city.GetHashCode()) % 360;
        color = $"hsl({hue}, 70%, 45%)";
        _cityColors[city] = color;
        return color;
    }

    private void AddCacheEntry(string key, List<HouseLocation> data)
    {
        if (_boundsCache.ContainsKey(key))
        {
            return;
        }

        _boundsCache[key] = data;
        _cacheOrder.Enqueue(key);

        while (_cacheOrder.Count > 12)
        {
            var oldKey = _cacheOrder.Dequeue();
            _boundsCache.Remove(oldKey);
        }
    }

    private static (double South, double West, double North, double East) ExpandBounds(
        double south,
        double west,
        double north,
        double east,
        double factor)
    {
        var latPad = (north - south) * factor;
        var lngPad = (east - west) * factor;
        return (south - latPad, west - lngPad, north + latPad, east + lngPad);
    }

    private static string BuildCacheKey(double south, double west, double north, double east) =>
        $"{Math.Round(south, 2)}:{Math.Round(west, 2)}:{Math.Round(north, 2)}:{Math.Round(east, 2)}";

    private static string BuildVisualBucket(double south, double west, double north, double east, int zoom) =>
        $"{Math.Round((south + north) / 2, 2)}:{Math.Round((west + east) / 2, 2)}:{Math.Round(north - south, 2)}:{zoom}";

    public async ValueTask DisposeAsync()
    {
        _debounceCts?.Cancel();
        _debounceCts?.Dispose();
        _moveSemaphore.Dispose();

        if (_dotNetRef is not null)
        {
            try
            {
                await JS.InvokeVoidAsync("leafletInterop.disposeMap");
            }
            catch (Exception ex)
            {
                Logger.LogDebug(ex, "Error while disposing map interop.");
            }

            _dotNetRef.Dispose();
        }
    }
}
