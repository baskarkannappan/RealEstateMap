@page "/"
@using System.Text.RegularExpressions
@using RealEstateMap.Models
@using RealEstateMap.Services
@inject IJSRuntime JS
@inject IHouseService HouseService
@inject ILogger<MapPage> Logger
@implements IAsyncDisposable

<div class="map-page bootstrap-search-ui">
    <div class="container-fluid px-0">
        <header class="sticky-top filter-header">
            <div class="d-flex flex-wrap align-items-center gap-2 py-2 px-2 px-md-3">
                <button type="button" class="btn btn-dark btn-sm filter-chip">For Sale</button>

                <select class="form-select form-select-sm filter-select" @bind="PriceFilter">
                    <option>Price</option>
                    <option>200k-1.5M+</option>
                    <option>300k-2M+</option>
                    <option>500k-3M+</option>
                </select>

                <select class="form-select form-select-sm filter-select" @bind="BedsFilter">
                    <option>Beds</option>
                    <option>0+-5+</option>
                    <option>1+-6+</option>
                    <option>2+-7+</option>
                </select>

                <select class="form-select form-select-sm filter-select" @bind="HomeTypeFilter">
                    <option>Home Type</option>
                    <option>House</option>
                    <option>Condo</option>
                    <option>Townhouse</option>
                </select>

                <button type="button" class="btn btn-sm btn-outline-secondary" @onclick="OpenVerificationModal">
                    Save Search
                </button>

                <button type="button"
                        class="btn btn-sm btn-outline-primary ms-md-auto"
                        @onclick="ToggleMapAsync"
                        aria-pressed="@IsMapVisible"
                        aria-label="@(IsMapVisible ? "Hide map panel" : "Show map panel")">
                    @(IsMapVisible ? "Hide Map" : "Show Map")
                </button>
            </div>
        </header>

        @if (!string.IsNullOrWhiteSpace(StatusMessage))
        {
            <div class="alert alert-light status-card m-2 mb-0" role="status">@StatusMessage</div>
        }

        <div class="row g-0 split-pane @(IsMapVisible ? "map-visible" : "map-hidden")">
            @if (IsMapVisible)
            {
                <section class="col-12 col-md-7 map-pane-fixed">
                    <div id="map" class="map-container"></div>
                </section>
            }

            <section class="col-12 @(IsMapVisible ? "col-md-5" : "col-md-12") gallery-pane">
                <div class="gallery-scroller">
                    <HouseListView Houses="ListViewData"
                                   CenterLat="_activeCenterLat"
                                   CenterLng="_activeCenterLng"
                                   GeolocationStatus="@GeolocationStatus"
                                   OnSelect="OnHouseSelectedAsync" />
                </div>
            </section>
        </div>
    </div>

    @if (ShowVerificationModal)
    {
        <div class="modal fade show d-block" tabindex="-1" role="dialog" aria-modal="true">
            <div class="modal-dialog modal-dialog-centered">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Verification Required</h5>
                        <button type="button" class="btn-close" aria-label="Close" @onclick="CloseVerificationModal"></button>
                    </div>
                    <div class="modal-body">
                        <p class="mb-0">Real Estate boards require a verified email prior to accessing full listing data.</p>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-outline-secondary" @onclick="CloseVerificationModal">Close</button>
                        <button type="button" class="btn btn-primary" @onclick="CloseVerificationModal">Verify Email</button>
                    </div>
                </div>
            </div>
        </div>
        <div class="modal-backdrop fade show"></div>
    }
</div>

@code {
    private const int MarkerLimit = 200;
    private static readonly Regex PinRegex = new("^\\d{6}$", RegexOptions.Compiled);

    private static readonly Dictionary<string, (double Lat, double Lng)> PinCenters = new(StringComparer.OrdinalIgnoreCase)
    {
        ["110001"] = (28.6328, 77.2197),
        ["400001"] = (18.9388, 72.8354),
        ["560001"] = (12.9763, 77.6033),
        ["500001"] = (17.3850, 78.4867),
        ["600001"] = (13.0827, 80.2707),
        ["700001"] = (22.5726, 88.3639),
        ["411001"] = (18.5204, 73.8567),
        ["380001"] = (23.0225, 72.5714),
        ["302001"] = (26.9124, 75.7873),
        ["226001"] = (26.8467, 80.9462)
    };

    private static readonly Dictionary<string, (double Lat, double Lng)> PinPrefixCenters = new(StringComparer.OrdinalIgnoreCase)
    {
        ["110"] = (28.6139, 77.2090),
        ["400"] = (19.0760, 72.8777),
        ["560"] = (12.9716, 77.5946),
        ["500"] = (17.3850, 78.4867),
        ["600"] = (13.0827, 80.2707),
        ["700"] = (22.5726, 88.3639),
        ["411"] = (18.5204, 73.8567),
        ["380"] = (23.0225, 72.5714),
        ["302"] = (26.9124, 75.7873),
        ["226"] = (26.8467, 80.9462)
    };

    private static readonly Dictionary<string, (double Lat, double Lng)> CityCenters = new(StringComparer.OrdinalIgnoreCase)
    {
        ["mumbai|maharashtra"] = (19.0760, 72.8777),
        ["delhi|delhi"] = (28.6139, 77.2090),
        ["bengaluru|karnataka"] = (12.9716, 77.5946),
        ["hyderabad|telangana"] = (17.3850, 78.4867),
        ["chennai|tamil nadu"] = (13.0827, 80.2707),
        ["kolkata|west bengal"] = (22.5726, 88.3639),
        ["pune|maharashtra"] = (18.5204, 73.8567),
        ["ahmedabad|gujarat"] = (23.0225, 72.5714),
        ["jaipur|rajasthan"] = (26.9124, 75.7873),
        ["lucknow|uttar pradesh"] = (26.8467, 80.9462),
        ["mumbai"] = (19.0760, 72.8777),
        ["delhi"] = (28.6139, 77.2090),
        ["bengaluru"] = (12.9716, 77.5946),
        ["hyderabad"] = (17.3850, 78.4867),
        ["chennai"] = (13.0827, 80.2707),
        ["kolkata"] = (22.5726, 88.3639),
        ["pune"] = (18.5204, 73.8567),
        ["ahmedabad"] = (23.0225, 72.5714),
        ["jaipur"] = (26.9124, 75.7873),
        ["lucknow"] = (26.8467, 80.9462)
    };

    private DotNetObjectReference<MapPage>? _dotNetRef;
    private CancellationTokenSource? _debounceCts;
    private readonly SemaphoreSlim _moveSemaphore = new(1, 1);
    private readonly Dictionary<string, List<HouseLocation>> _boundsCache = new();
    private readonly Queue<string> _cacheOrder = new();
    private readonly Dictionary<string, string> _cityColors = new(StringComparer.OrdinalIgnoreCase);

    private int _moveVersion;
    private string? _lastVisualBucket;
    private bool _skipNextMapMovedEvent;
    private bool _isExplicitSearchInProgress;
    private bool _mapInitialized;
    private bool _pendingMapInit = true;

    private bool IsMapVisible = true;
    private double _savedLat = 20.5937;
    private double _savedLng = 78.9629;
    private int _savedZoom = 5;
    private double? _activeCenterLat = 20.5937;
    private double? _activeCenterLng = 78.9629;

    private string PostalCode = string.Empty;
    private string City = string.Empty;
    private string State = string.Empty;
    private double RadiusKm = 10;
    private string PriceFilter = "200k-1.5M+";
    private string BedsFilter = "0+-5+";
    private string HomeTypeFilter = "Home Type";
    private string GeolocationStatus = "Geolocation: Checking...";
    private bool ShowVerificationModal;
    private string? StatusMessage;
    private List<HouseLocation> ListViewData = [];

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (IsMapVisible && (_pendingMapInit || firstRender) && !_mapInitialized)
        {
            _dotNetRef ??= DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("leafletInterop.initMap", "map", _savedLat, _savedLng, _savedZoom, _dotNetRef);
            _pendingMapInit = false;
            _mapInitialized = true;
        }

        if (firstRender)
        {
            await ResolveGeolocationStatusAsync();
        }
    }

    [JSInvokable(nameof(MapMoved))]
    public Task MapMoved(double south, double west, double north, double east, int zoom)
    {
        if (!IsMapVisible)
        {
            return Task.CompletedTask;
        }

        if (_skipNextMapMovedEvent)
        {
            _skipNextMapMovedEvent = false;
            return Task.CompletedTask;
        }

        if (_isExplicitSearchInProgress)
        {
            return Task.CompletedTask;
        }

        _debounceCts?.Cancel();
        _debounceCts?.Dispose();
        _debounceCts = new CancellationTokenSource();

        var version = Interlocked.Increment(ref _moveVersion);
        return ProcessMoveDebouncedAsync(south, west, north, east, zoom, version, _debounceCts.Token);
    }

    private async Task ProcessMoveDebouncedAsync(
        double south,
        double west,
        double north,
        double east,
        int zoom,
        int version,
        CancellationToken cancellationToken)
    {
        try
        {
            await Task.Delay(300, cancellationToken);
            if (!IsMapVisible)
            {
                return;
            }

            var bucket = BuildVisualBucket(south, west, north, east, zoom);
            if (_lastVisualBucket == bucket)
            {
                return;
            }

            await _moveSemaphore.WaitAsync(cancellationToken);
            try
            {
                if (version != _moveVersion || !IsMapVisible)
                {
                    return;
                }

                _lastVisualBucket = bucket;
                StatusMessage = null;

                var expanded = ExpandBounds(south, west, north, east, 0.35);
                var cacheKey = BuildCacheKey(expanded.South, expanded.West, expanded.North, expanded.East);

                if (!_boundsCache.TryGetValue(cacheKey, out var candidates))
                {
                    Logger.LogInformation("Fetching bounds from API: {South},{West},{North},{East}", expanded.South, expanded.West, expanded.North, expanded.East);
                    candidates = await HouseService.GetBoundsAsync(expanded.South, expanded.West, expanded.North, expanded.East, cancellationToken);
                    AddCacheEntry(cacheKey, candidates);
                }

                var visible = candidates
                    .Where(h => h.Lat >= south && h.Lat <= north && h.Lng >= west && h.Lng <= east)
                    .Take(MarkerLimit)
                    .ToList();

                _activeCenterLat = (south + north) / 2;
                _activeCenterLng = (west + east) / 2;

                ListViewData = visible;
                await RenderMarkersAsync(visible, zoom);
                await InvokeAsync(StateHasChanged);
            }
            finally
            {
                _moveSemaphore.Release();
            }
        }
        catch (OperationCanceledException)
        {
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "MapMoved pipeline failed.");
            StatusMessage = "Unable to load map data currently. Please continue navigating.";
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task SearchAsync()
    {
        try
        {
            var request = BuildSearchRequest();
            if (request is null)
            {
                return;
            }

            _isExplicitSearchInProgress = true;
            _activeCenterLat = request.CenterLat;
            _activeCenterLng = request.CenterLng;
            _skipNextMapMovedEvent = true;
            _lastVisualBucket = null;
            _boundsCache.Clear();
            _cacheOrder.Clear();

            await JS.InvokeVoidAsync("leafletInterop.clearLayers");
            await JS.InvokeVoidAsync("leafletInterop.clearRadius");

            var listResults = await HouseService.GetListAsync(request);
            ListViewData = listResults.Take(MarkerLimit).ToList();

            if (!IsMapVisible)
            {
                StatusMessage = $"Loaded {ListViewData.Count} properties in list view.";
                await InvokeAsync(StateHasChanged);
                return;
            }

            var mapResults = await HouseService.SearchByCenterAsync(
                request.CenterLat!.Value,
                request.CenterLng!.Value,
                request.RadiusKm,
                request.PostalCode,
                request.City,
                request.State);

            if (mapResults.Count == 0)
            {
                StatusMessage = "No properties matched your filters.";
                await JS.InvokeVoidAsync("leafletInterop.clearLayers");
                await JS.InvokeVoidAsync("leafletInterop.showSearchResult", request.CenterLat!.Value, request.CenterLng!.Value, 12, request.RadiusKm);
                await InvokeAsync(StateHasChanged);
                return;
            }

            var centerLat = request.CenterLat ?? _savedLat;
            var centerLng = request.CenterLng ?? _savedLng;
            _savedLat = centerLat;
            _savedLng = centerLng;
            _savedZoom = 12;

            var limited = mapResults.Take(MarkerLimit).ToList();
            await JS.InvokeVoidAsync("leafletInterop.showSearchResult", centerLat, centerLng, 12, request.RadiusKm);
            await RenderMarkersAsync(limited, 12);

            StatusMessage = $"Loaded {limited.Count} properties.";
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Search pipeline failed.");
            StatusMessage = "Search is temporarily unavailable.";
            await InvokeAsync(StateHasChanged);
        }
        finally
        {
            _isExplicitSearchInProgress = false;
        }
    }

    private async Task ToggleMapAsync()
    {
        try
        {
            if (IsMapVisible)
            {
                try
                {
                    var view = await JS.InvokeAsync<MapViewState?>("leafletInterop.getCurrentView");
                    if (view is not null)
                    {
                        _savedLat = view.Lat;
                        _savedLng = view.Lng;
                        _savedZoom = view.Zoom;
                    }
                }
                catch (Exception ex)
                {
                    Logger.LogDebug(ex, "Unable to read current map view before hide.");
                }

                await JS.InvokeVoidAsync("leafletInterop.disposeMap");
                _mapInitialized = false;
                IsMapVisible = false;
            }
            else
            {
                IsMapVisible = true;
                _pendingMapInit = true;
                _mapInitialized = false;
            }

            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed toggling map/list view.");
        }
    }

    private async Task OnHouseSelectedAsync(HouseLocation house)
    {
        StatusMessage = $"Selected: {house.Address} ({house.City})";

        if (!IsMapVisible)
        {
            return;
        }

        _savedLat = house.Lat;
        _savedLng = house.Lng;
        _activeCenterLat = house.Lat;
        _activeCenterLng = house.Lng;
        _savedZoom = Math.Max(_savedZoom, 12);
        await JS.InvokeVoidAsync("leafletInterop.showSearchResult", _savedLat, _savedLng, _savedZoom, RadiusKm);
    }

    private MapSearchRequest? BuildSearchRequest()
    {
        var pin = string.IsNullOrWhiteSpace(PostalCode) ? null : PostalCode.Trim();
        if (!string.IsNullOrWhiteSpace(pin) && !PinRegex.IsMatch(pin))
        {
            StatusMessage = "Please enter a valid 6-digit Indian PIN code.";
            return null;
        }

        var city = string.IsNullOrWhiteSpace(City) ? null : City.Trim();
        var state = string.IsNullOrWhiteSpace(State) ? null : State.Trim();

        if (!TryResolveCenter(pin, city, state, out var centerLat, out var centerLng))
        {
            StatusMessage = "Could not resolve search center for the provided India location.";
            return null;
        }

        return new MapSearchRequest
        {
            PostalCode = pin,
            City = city,
            State = state,
            CenterLat = centerLat,
            CenterLng = centerLng,
            RadiusKm = Math.Clamp(RadiusKm, 1, 250)
        };
    }

    private static bool TryResolveCenter(string? postalCode, string? city, string? state, out double lat, out double lng)
    {
        if (!string.IsNullOrWhiteSpace(postalCode))
        {
            if (PinCenters.TryGetValue(postalCode, out var exactPinCenter))
            {
                lat = exactPinCenter.Lat;
                lng = exactPinCenter.Lng;
                return true;
            }

            if (postalCode.Length >= 3)
            {
                var prefix = postalCode[..3];
                if (PinPrefixCenters.TryGetValue(prefix, out var prefixCenter))
                {
                    lat = prefixCenter.Lat;
                    lng = prefixCenter.Lng;
                    return true;
                }
            }
        }

        if (!string.IsNullOrWhiteSpace(city) && !string.IsNullOrWhiteSpace(state))
        {
            var key = $"{city.ToLowerInvariant()}|{state.ToLowerInvariant()}";
            if (CityCenters.TryGetValue(key, out var cityStateCenter))
            {
                lat = cityStateCenter.Lat;
                lng = cityStateCenter.Lng;
                return true;
            }
        }

        if (!string.IsNullOrWhiteSpace(city) && CityCenters.TryGetValue(city.ToLowerInvariant(), out var cityCenter))
        {
            lat = cityCenter.Lat;
            lng = cityCenter.Lng;
            return true;
        }

        lat = 0;
        lng = 0;
        return false;
    }

    private async Task RenderMarkersAsync(List<HouseLocation> houses, int zoom)
    {
        if (!IsMapVisible)
        {
            return;
        }

        await JS.InvokeVoidAsync("leafletInterop.clearLayers");

        if (zoom < 10)
        {
            var grouped = houses
                .GroupBy(h => (Math.Round(h.Lat, 1), Math.Round(h.Lng, 1)))
                .Select(group => new { Lat = group.Key.Item1, Lng = group.Key.Item2, Count = group.Count() });

            foreach (var cluster in grouped)
            {
                await JS.InvokeVoidAsync("leafletInterop.addClusterCount", cluster.Lat, cluster.Lng, cluster.Count);
            }

            return;
        }

        foreach (var house in houses)
        {
            var color = GetCityColor(house.City);
            await JS.InvokeVoidAsync(
                "leafletInterop.addMarker",
                house.Lat,
                house.Lng,
                $"{house.Address} - {house.City}, {house.State} ({house.PostalCode})",
                color);
        }
    }

    private string GetCityColor(string city)
    {
        if (string.IsNullOrWhiteSpace(city))
        {
            return "#1f77b4";
        }

        if (_cityColors.TryGetValue(city, out var color))
        {
            return color;
        }

        var hue = Math.Abs(city.GetHashCode()) % 360;
        color = $"hsl({hue}, 70%, 45%)";
        _cityColors[city] = color;
        return color;
    }

    private void AddCacheEntry(string key, List<HouseLocation> data)
    {
        if (_boundsCache.ContainsKey(key))
        {
            return;
        }

        _boundsCache[key] = data;
        _cacheOrder.Enqueue(key);

        while (_cacheOrder.Count > 12)
        {
            var oldKey = _cacheOrder.Dequeue();
            _boundsCache.Remove(oldKey);
        }
    }

    private static (double South, double West, double North, double East) ExpandBounds(
        double south,
        double west,
        double north,
        double east,
        double factor)
    {
        var latPad = (north - south) * factor;
        var lngPad = (east - west) * factor;
        return (south - latPad, west - lngPad, north + latPad, east + lngPad);
    }

    private static string BuildCacheKey(double south, double west, double north, double east) =>
        $"{Math.Round(south, 2)}:{Math.Round(west, 2)}:{Math.Round(north, 2)}:{Math.Round(east, 2)}";

    private static string BuildVisualBucket(double south, double west, double north, double east, int zoom) =>
        $"{Math.Round((south + north) / 2, 2)}:{Math.Round((west + east) / 2, 2)}:{Math.Round(north - south, 2)}:{zoom}";

    public async ValueTask DisposeAsync()
    {
        _debounceCts?.Cancel();
        _debounceCts?.Dispose();
        _moveSemaphore.Dispose();

        if (_dotNetRef is not null)
        {
            try
            {
                await JS.InvokeVoidAsync("leafletInterop.disposeMap");
            }
            catch (Exception ex)
            {
                Logger.LogDebug(ex, "Error while disposing map interop.");
            }

            _dotNetRef.Dispose();
        }
    }

    private void OpenVerificationModal() => ShowVerificationModal = true;

    private void CloseVerificationModal() => ShowVerificationModal = false;

    private async Task ResolveGeolocationStatusAsync()
    {
        try
        {
            GeolocationStatus = await JS.InvokeAsync<string>("leafletInterop.getGeolocationStatus");
        }
        catch
        {
            GeolocationStatus = "Geolocation: Unavailable";
        }

        await InvokeAsync(StateHasChanged);
    }

    private sealed class MapViewState
    {
        public double Lat { get; set; }
        public double Lng { get; set; }
        public int Zoom { get; set; }
    }
}
